#include <TFT.h>
#include <SPI.h>


const int PIN_DISPLAY_CS = 10;
const int PIN_DISPLAY_DC = 9;
const int PIN_DISPLAY_RST = 8;

const int PIN_ENCODER_A = 5;
const int PIN_ENCODER_B = 4;
const int PIN_ENCODER_CLICK = 6;
const int ENCODER_STEPS = 20;

const int FONT_SIZE = 1;
const int FONT_WIDTH = 5;
const int FONT_HEIGHT = 8;
const int LINE_HEIGHT = 10;
const int SPACER_SIZE = 8;
const int DISPLAY_PANEL_MARGIN = 4;
const int BACKGROUND_RED = 8;
const int BACKGROUND_GREEN = 0;
const int BACKGROUND_BLUE = 15;
const int BORDER_RED = 140;
const int BORDER_GREEN = 10;
const int BORDER_BLUE = 15;
const int TEXT_RED = 125;
const int TEXT_GREEN = 125;
const int TEXT_BLUE = 255;
const int SELECTED_TEXT_RED = 255;
const int SELECTED_TEXT_GREEN = 255;
const int SELECTED_TEXT_BLUE = 255;

const int CTRL_LABEL_LENGTH = 4;
const int CTRL_PER_ROW = 4;
const int NUM_BUTTONS = 4;
const int NUM_KNOBS = 16;
const int NUM_SWITCHES = 2;

const int NUM_EFFECTS = 2;
const int MAX_PATCH_NAME_LENGTH = 18;
const int MAX_EFFECT_NAME_LENGTH = 18;


class Effect {
  public:
    char effectName[MAX_PATCH_NAME_LENGTH + 1];
    char buttonLabels[NUM_BUTTONS][CTRL_LABEL_LENGTH + 1];
    char knobLabels[NUM_KNOBS][CTRL_LABEL_LENGTH + 1];
    char switchLabels[NUM_SWITCHES][CTRL_LABEL_LENGTH + 1];
    int numButtons;
    int numKnobs;
    int numSwitches;

    void setEffectName(char * effectName) {
      // Truncate to a max of MAX_EFFECT_NAME_LENGTH null terminated characters
      effectName[MAX_EFFECT_NAME_LENGTH] = 0;
      memcpy(this->effectName, effectName, MAX_EFFECT_NAME_LENGTH);
    }
  
    void setButtonLabel(int buttonNumber, char * label) {
      if (buttonNumber < 0 || buttonNumber >= NUM_KNOBS) {
        return;
      }
      // Truncate to a max of CTRL_LABEL_LENGTH null terminated characters
      buttonLabels[buttonNumber][CTRL_LABEL_LENGTH] = 0;
      memcpy(buttonLabels[buttonNumber], label, CTRL_LABEL_LENGTH);
    }
  
    void setKnobLabel(int knobNumber, char * label) {
      if (knobNumber < 0 || knobNumber >= NUM_KNOBS) {
        return;
      }
      // Truncate to a max of CTRL_LABEL_LENGTH null terminated characters
      knobLabels[knobNumber][CTRL_LABEL_LENGTH] = 0;
      memcpy(knobLabels[knobNumber], label, CTRL_LABEL_LENGTH);
    }
  
    void setSwitchLabel(int switchNumber, char * label) {
      if (switchNumber < 0 || switchNumber >= NUM_SWITCHES) {
        return;
      }
      // Truncate to a max of CTRL_LABEL_LENGTH null terminated characters
      switchLabels[switchNumber][CTRL_LABEL_LENGTH] = 0;
      memcpy(switchLabels[switchNumber], label, CTRL_LABEL_LENGTH);
    }  
};


class TemporalCollapseEffect: public Effect {
  public:
    TemporalCollapseEffect() {
      strcpy(effectName, "Temporal Collapse");
      
      numButtons = 2;
      char label[] = "1234";
      strcpy(label, "Buff");
      setButtonLabel(0, label);
      strcpy(label, "Dir");
      setButtonLabel(1, label);
    
      numKnobs = 12;
      strcpy(label, "Dry");
      setKnobLabel(0, label);
      strcpy(label, "Wet");
      setKnobLabel(1, label);
      strcpy(label, "Sens");
      setKnobLabel(2, label);
      strcpy(label, "Ltch");
      setKnobLabel(3, label);
      strcpy(label, "Time");
      setKnobLabel(4, label);
      strcpy(label, "Feed");
      setKnobLabel(5, label);
      strcpy(label, "Drft");
      setKnobLabel(6, label);
      strcpy(label, "Ltch");
      setKnobLabel(7, label);
      strcpy(label, "Smth");
      setKnobLabel(8, label);
      strcpy(label, "Smr");
      setKnobLabel(9, label);
      strcpy(label, "Driv");
      setKnobLabel(10, label);
      strcpy(label, "Crsh");
      setKnobLabel(11, label);
    
      numSwitches = 2;
      strcpy(label, "Ltch");
      setSwitchLabel(0, label);
      strcpy(label, "Tmpo");
      setSwitchLabel(1, label);
    }
};


class SubtractiveSynthEffect: public Effect {
  public:
    SubtractiveSynthEffect() {
      strcpy(effectName, "SubtractiveSynth");
      
      numButtons = 4;
      char label[] = "1234";
      strcpy(label, "Osc1");
      setButtonLabel(0, label);
      strcpy(label, "Osc2");
      setButtonLabel(1, label);
      strcpy(label, "Osc3");
      setButtonLabel(2, label);
      strcpy(label, "Port");
      setButtonLabel(3, label);
    
      numKnobs = 16;
      strcpy(label, "Oct");
      setKnobLabel(0, label);
      strcpy(label, "Det");
      setKnobLabel(1, label);
      strcpy(label, "OEnv");
      setKnobLabel(2, label);
      strcpy(label, "OLFO");
      setKnobLabel(3, label);
      strcpy(label, "Cut");
      setKnobLabel(4, label);
      strcpy(label, "Res");
      setKnobLabel(5, label);
      strcpy(label, "FEnv");
      setKnobLabel(6, label);
      strcpy(label, "FLFO");
      setKnobLabel(7, label);
      strcpy(label, "AEnv");
      setKnobLabel(8, label);
      strcpy(label, "ALFO");
      setKnobLabel(9, label);
      strcpy(label, "Rate");
      setKnobLabel(10, label);
      strcpy(label, "Wave");
      setKnobLabel(11, label);
      strcpy(label, "Att");
      setKnobLabel(12, label);
      strcpy(label, "Dec");
      setKnobLabel(13, label);
      strcpy(label, "Sus");
      setKnobLabel(14, label);
      strcpy(label, "Rel");
      setKnobLabel(15, label);
    
      numSwitches = 2;
      strcpy(label, "Mod");
      setSwitchLabel(0, label);
      strcpy(label, "Sus");
      setSwitchLabel(1, label);
    }
};


class Patch {
  public:
    char patchName[MAX_PATCH_NAME_LENGTH + 1];
    Effect effects[NUM_EFFECTS];

    void setPatchName(char * patchName) {
      this->patchName[MAX_PATCH_NAME_LENGTH] = 0;
      memcpy(this->patchName, patchName, MAX_PATCH_NAME_LENGTH);
    }

    void setEffect(int effectNumber, Effect effect) {
      if (effectNumber < 0 || effectNumber >= NUM_EFFECTS) {
        return;
      }

      effects[effectNumber] = effect;
    }

};


class DisplayPanel {
  private:
    bool needsRefresh;
  
  protected:
    TFT &tft;
  
  public:
    DisplayPanel(TFT &tft)
    : tft(tft) {
    }

    void invalidate() {
      needsRefresh = true;
    }

    void render(int xPos, int yPos, int width, int height) {
      if (needsRefresh) {
        doRender(xPos, yPos, width, height);
        needsRefresh = false;
      }
    }

    virtual void doRender(int xPos, int yPos, int width, int height);
};


class ControlsPanel: public DisplayPanel {
  public:
    using DisplayPanel::DisplayPanel;
    Effect effect;

    void doRender(int xPos, int yPos, int width, int height) {
      // Background and border
      tft.fill(BACKGROUND_BLUE, BACKGROUND_GREEN, BACKGROUND_RED);
      tft.stroke(BORDER_BLUE, BORDER_GREEN, BORDER_RED);
      tft.rect(xPos, yPos, width, height);

      // Buttons labels
      tft.stroke(TEXT_BLUE, TEXT_GREEN, TEXT_RED);
      for (int i = 0; i < effect.numButtons; i++) {
        tft.text(effect.buttonLabels[i],
            xPos + DISPLAY_PANEL_MARGIN + i * FONT_WIDTH * (CTRL_LABEL_LENGTH + 2),
            yPos + DISPLAY_PANEL_MARGIN
            );
      }

      // Knob labels
      for (int i = 0; i < effect.numKnobs; i++) {
        int row = i / CTRL_PER_ROW;
        int column = i % CTRL_PER_ROW;
        
        tft.text(effect.knobLabels[i],
            xPos + DISPLAY_PANEL_MARGIN + column * FONT_WIDTH * (CTRL_LABEL_LENGTH + 2),
            yPos + DISPLAY_PANEL_MARGIN + (row + 1) * LINE_HEIGHT + SPACER_SIZE
            );
      }

      // Switch labels
      for (int i = 0; i < effect.numSwitches; i++) {
        tft.text(effect.switchLabels[i],
            xPos + DISPLAY_PANEL_MARGIN + CTRL_PER_ROW * FONT_WIDTH * (CTRL_LABEL_LENGTH + 2) + SPACER_SIZE,
            yPos + DISPLAY_PANEL_MARGIN + SPACER_SIZE + i * 3 * LINE_HEIGHT
            );
      }
    }
};


class PatchPanel: public DisplayPanel {
  public:
    using DisplayPanel::DisplayPanel;

    Patch patch;
    int selectedEffect = 0;
    int selection = 0;

    Effect getSelectedEffect() {
      return patch.effects[selectedEffect];
    }

    void decrementSelect() {
      selection -= 1;
      if (selection < 0) {
        selection += NUM_EFFECTS + 5;
      }
      invalidate();
    }

    void incrementSelect() {
      selection = (selection + 1) % (NUM_EFFECTS + 5);
      invalidate();
    }

    // returns true if you need to invalidate all
    bool select() {
      if (selection == 0) {
      } else if (selection <= NUM_EFFECTS) {
        selectedEffect = selection - 1;
        invalidate();
        return true;
      } else if (selection == NUM_EFFECTS + 1) {
      } else if (selection == NUM_EFFECTS + 2) {
      } else if (selection == NUM_EFFECTS + 3) {
      } else if (selection == NUM_EFFECTS + 4) {
      }

      return false;
    }

    void doRender(int xPos, int yPos, int width, int height) {
      tft.fill(BACKGROUND_BLUE, BACKGROUND_GREEN, BACKGROUND_RED);
      tft.stroke(BORDER_BLUE, BORDER_GREEN, BORDER_RED);
      tft.rect(xPos, yPos, width, height);
      
      tft.stroke(TEXT_BLUE, TEXT_GREEN, TEXT_RED);

      // Patch name
      tft.text("Patch:", xPos + DISPLAY_PANEL_MARGIN, yPos + DISPLAY_PANEL_MARGIN);
      if (selection == 0) {
        tft.stroke(SELECTED_TEXT_BLUE, SELECTED_TEXT_GREEN, SELECTED_TEXT_RED);
      }
      tft.text(patch.patchName, xPos + DISPLAY_PANEL_MARGIN + 7 * FONT_WIDTH + SPACER_SIZE, yPos + DISPLAY_PANEL_MARGIN);
      tft.stroke(TEXT_BLUE, TEXT_GREEN, TEXT_RED);

      // Effect names
      char fxLabel[] = "FX 0:  ";
      for (int i = 0; i < NUM_EFFECTS; i++) {
        fxLabel[3] = '1' + i;
        if (selectedEffect == i) {
          fxLabel[6] = '>';
        } else {
          fxLabel[6] = ' ';
        }
        
        tft.text(fxLabel,
            xPos + DISPLAY_PANEL_MARGIN,
            yPos + DISPLAY_PANEL_MARGIN + SPACER_SIZE + (i + 1) * LINE_HEIGHT);
            
        if (selection == i + 1) {
          tft.stroke(SELECTED_TEXT_BLUE, SELECTED_TEXT_GREEN, SELECTED_TEXT_RED);
        }

        tft.text(patch.effects[i].effectName,
            xPos + DISPLAY_PANEL_MARGIN + 7 * FONT_WIDTH + SPACER_SIZE,
            yPos + DISPLAY_PANEL_MARGIN + SPACER_SIZE + (i + 1) * LINE_HEIGHT
            );

        tft.stroke(TEXT_BLUE, TEXT_GREEN, TEXT_RED);
      }

      // Options
      if (selection == NUM_EFFECTS + 1) {
        tft.stroke(SELECTED_TEXT_BLUE, SELECTED_TEXT_GREEN, SELECTED_TEXT_RED);
      }
      tft.text("NEW",
          xPos + DISPLAY_PANEL_MARGIN,
            yPos + DISPLAY_PANEL_MARGIN + 2 * SPACER_SIZE + 3 * LINE_HEIGHT
          );
      tft.stroke(TEXT_BLUE, TEXT_GREEN, TEXT_RED);

      if (selection == NUM_EFFECTS + 2) {
        tft.stroke(SELECTED_TEXT_BLUE, SELECTED_TEXT_GREEN, SELECTED_TEXT_RED);
      }
      tft.text("COPY",
          xPos + DISPLAY_PANEL_MARGIN + FONT_WIDTH * 7,
            yPos + DISPLAY_PANEL_MARGIN + 2 * SPACER_SIZE + 3 * LINE_HEIGHT
          );
      tft.stroke(TEXT_BLUE, TEXT_GREEN, TEXT_RED);

      if (selection == NUM_EFFECTS + 3) {
        tft.stroke(SELECTED_TEXT_BLUE, SELECTED_TEXT_GREEN, SELECTED_TEXT_RED);
      }
      tft.text("RENAME",
          xPos + DISPLAY_PANEL_MARGIN + FONT_WIDTH * 15,
            yPos + DISPLAY_PANEL_MARGIN + 2 * SPACER_SIZE + 3 * LINE_HEIGHT
          );
      tft.stroke(TEXT_BLUE, TEXT_GREEN, TEXT_RED);

      if (selection == NUM_EFFECTS + 4) {
        tft.stroke(SELECTED_TEXT_BLUE, SELECTED_TEXT_GREEN, SELECTED_TEXT_RED);
      }
      tft.text("SAVE",
          xPos + DISPLAY_PANEL_MARGIN + FONT_WIDTH * 25,
            yPos + DISPLAY_PANEL_MARGIN + 2 * SPACER_SIZE + 3 * LINE_HEIGHT
          );
      tft.stroke(TEXT_BLUE, TEXT_GREEN, TEXT_RED);
    }
};


class FilePanel: public DisplayPanel {
  public:
    using DisplayPanel::DisplayPanel;
};


class Window {
  private:
    PatchPanel patchPanel;
    ControlsPanel controlsPanel;

  public:
    Window(TFT &tft) 
      : patchPanel(tft)
      , controlsPanel(tft)
    {
    }

    void render() {
      patchPanel.render(0, 0, 160, 64);
      controlsPanel.render(0, 64, 160, 64);
    }

    void invalidate() {
      controlsPanel.invalidate();
      patchPanel.invalidate();
    }
  
    void scrollDown() {
      patchPanel.incrementSelect();
    }

    void scrollUp() {
      patchPanel.decrementSelect();
    }

    void select() {
      if (patchPanel.select()) {
        controlsPanel.effect = patchPanel.getSelectedEffect();
        invalidate();
      }
    }

    void createTestData() {
        // TEST DATA
      char patchName[] = "123456789012345678";
      strcpy(patchName, "Return Of The Jedi");
      patchPanel.patch.setPatchName(patchName);
    
      SubtractiveSynthEffect effect0;
      patchPanel.patch.setEffect(0, effect0);
    
      TemporalCollapseEffect effect1;
      patchPanel.patch.setEffect(1, effect1);
    
      int selectedEffect = 0;
      patchPanel.selectedEffect = selectedEffect;
      controlsPanel.effect = patchPanel.patch.effects[selectedEffect];
    }

};


TFT tft = TFT(PIN_DISPLAY_CS, PIN_DISPLAY_DC, PIN_DISPLAY_RST);
Window window(tft);


void setup() {
  pinMode(PIN_ENCODER_A, INPUT_PULLUP);
  pinMode(PIN_ENCODER_B, INPUT_PULLUP);
  pinMode(PIN_ENCODER_CLICK, INPUT_PULLUP);
  
  //initialize the library
  tft.begin();

  // clear the screen with a black background
  tft.background(BACKGROUND_BLUE, BACKGROUND_GREEN, BACKGROUND_RED);
  //set the text size
  tft.setTextSize(FONT_SIZE);

  window.createTestData();
  window.invalidate();
}


void loop() {
  static bool encoderALast = LOW;
  
  bool encoderA = digitalRead(PIN_ENCODER_A);
  if ((encoderALast == HIGH) && (encoderA == LOW)) {
    if (digitalRead(PIN_ENCODER_B)) {
      window.scrollUp();
    } else {
      window.scrollDown();
    }
  }
  encoderALast = encoderA;

  if (digitalRead(PIN_ENCODER_CLICK) == LOW) {
    window.select();
  }

  window.render();
}
